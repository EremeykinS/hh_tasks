# О репозитории
В этом репозитории размещены мои решения задач, предлагаемых в 2017 году на первом туре отбора в [Школу программистов HeadHunter](https://school.hh.ru/).  
Всего предлагалось решить пять задач, однако, мне удалось решить лишь шесть из них. Ниже приведены условия задач, а решения на Python 3 - в файлах `*.py`  
Стоит отметить, что решения большинства задач (пожалуй, всех, кроме пятой) были написаны по-быстрому "на коленке", поэтому качество решения может быть на низком уровне. Тем не менее, этого хватило, чтобы пройти во второй тур отбора (проверялись только ответы). 

# Задача 1
Рассмотрим все возможные числа a<sup>b</sup> для 1<a<6 и 1<b<6:  
2<sup>2</sup>=4, 2<sup>3</sup>=8, 2<sup>4</sup>=16, 2<sup>5</sup>=32, 3<sup>2</sup>=9, 3<sup>3</sup>=27, 3<sup>4</sup>=81, 3<sup>5</sup>=243, 4<sup>2</sup>=16, 4<sup>3</sup>=64, 4<sup>4</sup>=256, 4<sup>5</sup>=1024, 5<sup>2</sup>=25, 5<sup>3</sup>=125, 5<sup>4</sup>=625, 5<sup>5</sup>=3125.  
Если убрать повторения, то получим 15 различных чисел.  
Сколько различных чисел a<sup>b</sup> для 2<a<100 и 2<b<136?
### Комментарии к решению
Задача решается простым перебором. Чтобы отбросить повторяющиеся числа, было использовано свойство множеств исключать повторяющиеся элементы.

# Задача 2
В некоторых числах можно найти последовательности цифр, которые в сумме
дают 10. К примеру, в числе 3523014 целых четыре таких последовательности:  
<u>**352**</u>3014  
3<u>**523**</u>014  
3<u>**5230**</u>14  
35<u>**23014**</u>  

Можно найти и такие замечательные числа, каждая цифра которых входит в по крайней мере одну такую последовательность. Например, 3523014 является замечательным числом, а 28546 — нет (в нём нет последовательности цифр, дающей в сумме 10 и при этом включающей 5). Найдите количество этих замечательных чисел в интервале \[1, 6000000\] (обе границы — включительно).
### Комментарии к решению
Была написана простая функция проверки, является ли число "замечательным". Эта функция вычисляет количество вхождений каждой цифры в последовательности, дающие в сумме 10. Результатом функции становится логическое значение, получаемое с помощью функции `all()`, которое показывает, есть ли в числе цифры, не вошедшие ни в одну последовательность, дающую в сумме 10 (и, соответственно, является ли число "замечательным"). Написанная таким образом функция применяется в цикле ко всем числам в заданном интервале и ведется подсчет "замечательных" чисел.

# Задача 3
Если мы возьмем 47, перевернем его и сложим, получится 47 + 74 = 121 —
число-палиндром.

Если взять 349 и проделать над ним эту операцию три раза, то тоже получится палиндром:  
349 + 943 = 1292  
1292 + 2921 = 4213  
4213 + 3124 = 7337  
Найдите количество положительных натуральных чисел меньших 13110 таких, что из них нельзя получить палиндром за 50 или менее применений описанной операции (операция должна быть применена хотя бы один раз).
### Комментарии к решению
Сначала напишем простейшие вспомогательные функции: функция проверки на полиндром, функцию получения перевернутого числа, функцию для описанной в условиии операции (сложение числа с перевернутым). Затем пишем основную функцию, которая будет проверять, можно ли получить палиндром за 50 или менее применений описанной операции палиндром из заданного числа. Функция работает "в лоб": применяет операцию (с помощью ранее написанной вспомогательной функции), подсчитывая при этом количество применений. Если получился палиндром, и при этом насчитали менее 50 применений, то число не подходит, функция возвращает `False`. А если насчитали более 50 применений, значит, число подходит и функция возвращает `True`. Применяя эту функцию ко всем числам в заданном диапазоне, находим ответ к задаче.

# Задача 4
Дано равенство, в котором цифры заменены на буквы:  
vww + rwzw = ssws  
Найдите сколько у него решений, если различным буквам соответствуют
различные цифры (ведущих нулей в числе не бывает).
### Комментарии к решению
Задача решается перебором. По условию всего 5 неизвестных: v,r,s,w,z. Поэтому организуем 5 вложенных циклов, перебирающих все подходящие цифры. В соответствии с условием различным буквам соответствуют различные цифры. Это условие легко проверять, используя свойство множества исключать повторяющиеся элементы. Таким образом, создаем множество `d=set([v,r,s,w,z])` и проверяем условие `len(d)==5`, чтобы убедиться, что все цифры - различные. При выполнении этого условия, внутри самого вложенного цикла просто инкрементируем значение переменной `num` для подсчета искомого количества решений.

# Задача 5
Наименьшее число m, такое, что m! делится без остатка на 10 — это m=5 (5! = 120). Аналогично, наименьшее число m, такое, что m! делится без остатка на 25 — это m=10. В общем случае, значение функции s(n) равно наименьшему числу m, такому что m! без остатка делится на n. Определим функцию S(M, N) = Σs(n) для всех n ∈ [M, N]. К примеру, S(6, 10) = 3 + 7 + 4 + 6 + 5 = 25.  
Найдите S(6600000, 6700000).
### Комментарии к решению
Сразу отмечу, что при решении этой задачи действительно пришлось **напрячь мозг**. У меня сразу возникли опасения, что решение "в лоб" здесь будет работать неприемлемо медленно. Эти опасения полностью оправдались - из заданного интервала, содержащего 100001 число, за несколько минут удалось вычислить только лишь несколько (не более 5) первых значений! Стало очевидно, что для решения этой задачи необходимо привлечь какие-то математические соображения, которые бы позволили существенно ускорить расчет. Размышляя, я понял, что раз в задаче говорится о делимости, то следует рассматривать разложения на [простые](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE "Статья о простых числах в Википедии") множители, с учетом того, что факториал числа n! представляет собой произведение всех натуральных чисел от 1 до n. И так, основную идею разработанного алгоритма быстрого вычисления s(n) можно объяснить упрощенно следующим образом.
Разложим аргумент n функции s(n) на простые множители (с определением кратности каждого множителя). Если оказывается, что n является простым, можно сразу сделать вывод, что наименьшим числом m, таким что m! без остатка делится на n, является n. Это можно понять, рассуждая следующим образом. При m = n, очевидно m! делится без остатка на n (по определению факториала). При этом меньшее m подобрать не получится, так как ни в одном m! при m < n не "встречается" n в качестве множителя. 
Если же n **не** является простым, придется рассматривать полное разложение n на простые множители. В общем случае разложение можно представить в виде набора пар простых множителей с соответствующими им кратностями: {f<sub>1</sub>:k<sub>1</sub>, f<sub>2</sub>:k<sub>2</sub>, ..., f<sub>p</sub>:k<sub>p</sub>}. Для каждой пары (f<sub>i</sub>:k<sub>i</sub>) из этого множества вычисляем минимальное число, m, такое, что m! делится без остатка на f<sub>i</sub><sup>k<sub>i</sub></sup>. Для этого перебираем все числа начиная с f с шагом f (то есть f, 2*f, 3*f, 4*f, ...) до тех пор, пока не наберется требуемая кратность k<sub>i</sub> множителя f<sub>i</sub> (в коде за это отвечает переменная `killed`, значение которой уменьшается в процессе работы соответствующим образом до тех пор, пока оно не перестанет быть положительным). Все полученные таким образом числа m помещаются в список, обозначенный в коде `pointers`. Результатом работы функции `s(n)` становится максимальное значение из этого списка. В процессе работы функция `s(n)` вызывает вспомогательные функции `is_prime(x)` и `prime_factors(x)`. Функция `is_prime(x)` возвращает значение логического типа, показывающее, является ли число `x` простым, а функция `prime_factors(x)` возвращает разложение числа `x` на простые множители в виде картежа, содержащего картежи из двух чисел, первое из которых представляет кратность простого множителя, а второе - соответствующий простой множитель. Каждая из этих функций снабжена декоратором `@lru_cache`. Это позволяет организовать кеширование результатов и не пересчитывать повторно значения функций для одних и тех же значений аргументов. Функция `S(t)` не содержит никаких интересных особенностей и просто вычисляет требуемую сумму `s(i)` для всех значений i в заданном диапазоне. Однако так как диапазон значений, для которого требуется посчитать сумму, относительно большой, то для ускорения решения логично распараллелить вычисления. Для этого в главной функции `main()` используется `concurrent.futures.ProcessPoolExecutor`. Весь требуемый диапазон разбивается на несколько диапазонов (в данном конкретном случае на 4), для каждого из которых вычисляется сумма, после чего все результаты суммируются для получения окончательного результата - суммы на всем диапазоне. Такой способ позволяет уменьшить время выполнения вычислений до обозримого (порядка часа).

# Задача 6
Рассмотрим спираль, в которой, начиная с 1 в центре, последовательно расставим числа по часовой стрелке, пока не получится спираль 5 на 5
```
   21 22 23 24 25
   20  7  8  9 10
   19  6  1  2 11
   18  5  4  3 12
   17 16 15 14 13
```
Можно проверить, что сумма всех чисел на диагоналях равна 101. Найти сумму чисел на диагоналях для спирали размером 1169 на 1169.
### Комментарии к решению
По всей видимости, для этой задачи можно вывести формулу, которая бы давала нужную сумму в зависимости от размера матрицы, но мне было ~~лень~~ некогда раздумывать над выводом, так что я решил задачу примитивным способом - "в лоб", заполнив матрицу (список списков в Python) спиралью и посчитав сумму диагональных элементов. Для этого я сначала написал вспомогательную функцию, которая делает очередной виток спирали. Это довольно простая функция, я назвал её `next_turn()`. Она сначала заполняет столбец сверху вниз, затем строку справа налево, затем столбец снизу вверх, и, наконец, строку справа налево. Таким образом, образуется очередной виток. На вход такая функция принимает матрицу `M`, в которой надо сделать виток, координаты `i`, `j` начала витка, размер витка `n` (виток квадратный), а также итератор `counter`, пораждающий следующее число. Затем эта функция `next_turn()` вызывается в цикле до тех пор, пока не будет заполнена матрица требуемого размера. После того, как матрица заполнена, вычисляем требуемую сумму как
```sum(M[i][i] for i in range(N))+sum(M[i][N-i-1] for i in range(N))-1```
Здесь первое слогаемое - сумма чисел на главной диагонали, второе - сумма чисел на побочной диагонали, а `-1` необходимо добавить, так как центральная единица вошла в первые два слогаемых дважды.
